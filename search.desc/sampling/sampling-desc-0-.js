searchState.loadedDescShard("sampling", 0, "For sampling ensembles\nBootstrap resampling functions\nFor using entropic sampling after a wang landau simulation\nContains examples\nGlue together overlapping intervals of either entropic …\nGenerate heatmaps. Create Gnuplot scripts to plot said …\nTraits for implementing histograms for Wang Landau or …\nFor making a Metropolis simulation\nEntropic sampling using a replica exchange approach\nReplica exchange wang-landau\nContains traits useful for sampling an ensemble like …\nWang Landau Implementation\nreturns reduced value + estimated error (as sqrt of …\nSimilar to bootstrap but for stuff that implements <code>Copy</code>. …\nTraits for quantities that all Entropic simulations have\nHelper trait, so that you have to type less\ntrait to request the current energy from a Entropic …\ntrait to request a reference to the current (state of the) …\nError states, that entropic sampling, or the creation of …\ntrait to request the current histogram from a Entropic …\nEntropic sampling made easy\nEntropic sampling made easy\nStill Gathering Statistics, this is only an estimate!\nYou are trying to have a <code>min_best_of_count</code> that is larger …\nPossible reasons\nInvalid trial step. Is your max_step smaller than your …\nsource (<code>WangLandauAdaptive</code>) was in an invalid state\nStill in the process of gathering statistics Not enough to …\nCurrently used best of\nreturns the last accepted <code>Energy</code> calculated <code>None</code> if no …\nEnergy of ensemble\nEnergy of ensemble\nEnergy of ensemble\nEnergy of ensemble\nreturn reference to current state of ensemble\nCurrent state of the Ensemble\nCurrent state of the Ensemble\nreturns mutable reference to ensemble\nEntropic sampling\nEntropic sampling\nEntropic sampling using an accumulating markov step\nEntropic sampling using an accumulating markov step\nEntropic sampling\nEntropic sampling\nEntropic sampling\nEntropic sampling\nEntropic sampling using an accumulating markov step\nEntropic sampling using an accumulating markov step\nEntropic sampling\nEntropic sampling\nEntropic step\nEntropic step\nAccumulating entropic step\nEntropic sampling using an accumulating markov step\nEntropic step\nEntropic step\nEstimate accept/reject statistics\nFraction of steps accepted since the statistics were reset …\nCalculate, which fraction of steps were accepted\nCalculate, which fraction of steps were accepted\nFraction of steps accepted since the creation of <code>self</code>\nFraction of steps accepted since the creation of <code>self</code>\nCalculate, which fraction of steps were rejected\nCalculate, which fraction of steps were rejected\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates Entropic from a <code>WangLandauAdaptive</code> state\nCreates EntropicSamplingAdaptive from a <code>WangLandauAdaptive</code> …\nCreates Entropic from a <code>WangLandauAdaptive</code> state\nreturns current histogram\nReturn current state of histogram\nReturn current state of histogram\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks wang landau threshold\nChecks wang landau threshold\nIs the simulation in the process of rebuilding the …\nCurrent (non normalized) estimate of ln(P(E))\nCurrent (non normalized) estimate of log_base(P(E))\nCurrent (non normalized) estimate of log_base(P(E))\nCurrent (non normalized) estimate of log10(P(E))\nCurrent (non normalized) estimate of log10(P(E))\nreturns the (non normalized) log_density estimate …\nreturns the (non normalized) log_density estimate …\ncalculates the (non normalized) log_density estimate …\ncalculates the (non normalized) log_density estimate …\nLargest possible markov step (<code>m_steps</code> of MarkovChain …\nSmallest possible markov step (<code>m_steps</code> of MarkovChain …\nCalculates <code>self.log_density_refined</code> and uses that as …\nCalculates <code>self.log_density_refined</code> and uses that as …\nHow often to adjust <code>bestof_steps</code>?\nNumber of entropic steps to be performed\nNumber of entropic steps to be performed\nNumber of entropic steps done until now\nCounter\nNumber of entropic steps done until now\nNumber of entropic steps done until now\nWhat is the goal to reach?\nNumber of entropic steps to be performed\nNumber of entropic steps to be performed\nNumber of entropic steps to be performed\nSmallest possible markov step (<code>m_steps</code> of MarkovChain …\nCounter\nCounter\ntotal number of entropic steps, that were accepted\ntotal number of entropic steps, that were rejected\nHow many steps were accepted until now?\nHow many steps were rejected until now?\nUses as stepsize: first entry of bestof. If bestof is …\nWrites Information about the simulation to a file. E.g. …\nExample Coin flips\nResult of flipping a coin\nResult of markov Step\nA sequence of Coin flips. Contains random Number generator\nThe result is Head\nThe result is Tail\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCount how often <code>Head</code> occurs in the Coin flip sequence\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPerform a markov step\nOnly implemented for testcases\nOnly implemented for testcases\nCount many times <code>Head</code> occurred in a row\nCreate new coin flip sequence\nOnly implemented for testcases\nOnly implemented for testcases\nTurn Coin around, i.e., invert CoinFlip\nOnly implemented for testcases\nOnly implemented for testcases\nCalculate the head count, if a previous head count of the …\nOnly accumulated stats, i.e., key stats\nuse base 10\nuse base e\nBinary search failed - PartialOrd::partial_cmp returned …\n<code>original_hist.borders_clone()</code> failed\nNothing to be glued, glue interval list was empty\nSimulation was Entropic sampling\nSimulation was adaptive Entropic sampling\nTrait for objects that can contribute to a GlueJob\nStruct that is used to create a glue job\nPossible errors that can occur during gluing together …\nUsed to merge probability densities from WL, REWL, …\nIncludes statistics about the intervals from which the …\nWhich level of verbosity do you want?\nResult of the gluing\nStatistics of one interval, used to gauge how well the …\nStats for every single interval\nAccumulated stats AND stats for every single interval\nWhich LogBase is being used/should be used?\nThe logarithm of the factor f. Useful, since we often want …\nHow many steps do we still need to perform?\nThe intervals need to overlap, otherwise no gluing can …\nNo stats at all\nGlue interval and intervals to be glued do not match\nSimulation was Replica exchange Entropic sampling\nSimulation was Replica exchange Wang Landau (1/t)\nEnum which contains information about the current progress …\nEnum to track simulation type\nSimulation type is unknown\nThe simulation progress is unknown\nSimulation was a 1/t Wang-Landau simulation\nSimulation was an adaptive 1/t Wang-Landau simulation\nHow many steps were accepted in total in the interval\nAdd GlueAble objects via an iterator\nAdd a slice of GlueAble objects to the glue job\nGet alignment slice\nCalculate the probability density function from …\nCalculate the probability density function from …\nReturns the current base of the contained logarithms\nContains all the Intervals to glue\nModule for numeric derivatives\nCalculate the probability density function from …\nCalculate the probability density function from …\nThe logarithm base that we want our final output to be in\nReturns encapsulating Histogram\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet statistics of the current glue job. See GlueStats\nReturns Slice which represents the glued logarithmic …\nThe histogram\nWhich type of simulation did the interval come from\nList of the interval simulation stats of the intervals …\nStatistics about the intervals\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre the results currently in Logarithm base 10?\nAre the results currently in Logarithm base E?\nInformation about which logarithm base was used to store …\nThe number of walkers used to generate this sim. In …\nName of simulation type as &amp;str\nCreate a new glue job from something GlueAble See GlueAble\nCreate a glue job from an iterator of GlueAble objects\nCreate a glue job from a slice of GlueAble objects\nCreate a new <code>Glued&lt;Hist&gt;</code> instance without checking anything\nNormalize log10 probability density\nThe probability density distribution\nHow many replica exchanges were proposed? None for …\nAdd <code>self</code> to the GlueJob\nAdd <code>self</code> to the GlueJob\nAdd <code>self</code>to the GlueJob, but ignore some indices\nHow many steps were rejected in total in the interval\nHow many replica exchanges were performed? None for …\nContains information about the number of roundtrips of the …\nList of the round trips of the intervals used to create …\nSet the verbosity\nSet stats\nthe progress of the Interval\nChange from Base 10 to Base E or the other way round\nWrite the Glued in a human readable format\nWrite Stats to file\nWrites stats to a file\nWrite the normalized probability density function\nWrite the Glued Stats in a human readable way\nCalculates the derivative of a Vector\nCalculates the derivative of a Vector\nfive-point stencil derivative method\nRGB value\nUse a CubeHelix palette\nImplements color palett from …\nyou tried to combine heatmaps of different Dimensions\nDoes not specify a terminal\nUse EpsLatex as terminal in gnuplot\nuse labels\nconstruct the labels\nFor labeling the gnuplot plots axis\ndefines presets for different color palettes\nDefines gnuplot point\nSettings for gnuplot\nOptions for choosing gnuplot Terminal\nErrors of Heatmap\nHeatmap\nHeatmap with mean of y-axis\nShorthand for HeatmapUsize\nHeatmap\nHeatmap with mean of y-axis\nFor labeling the gnuplot plots axis\nUse pdf as gnuplot terminal\nA color palette in RGB space\nUse preset HSV palette\nUse preset RGB palette, i.e., the default palette of …\nDefine a palette in RGB space\nAn Error while calculating the index of the x coordinate\nAn Error while calculating the index of the y coordinate\nadd a color to the palette\nCalculate color from gray value.Gray value should be in …\ncounts how many bins of the heatmap where hit at least once\ncounts how many bins of the heatmap where never hit\nThe blue part\nBuilder pattern - set cb_range\nDefine the cb range if this option is set\nChoose the color for the point\nColor of the point\n“combine” heatmaps\n“combine” heatmaps\nUpdate heatmap\nUpdate heatmap\nupdate the heatmap\nupdate the heatmap\nUpdate Heatmap\nUpdate Heatmap\nupdate the heatmap\nWrite hex representation to a fmt writer\nwrite string to define this palette in gnuplot to fmt …\nShould there be a frame around the point ? This is good …\nshould the point have a frame?\nWhich color should the frame have?\nWhich color should the frame be?\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new GnuplotAxis::Labels\nSimilar to <code>from_labels</code>\nBuilder pattern - set gamma\nReturns value stored in the heatmap at specified …\nReturns value stored in the heatmap at specified …\nGet entry for legend\nrow of the heatmap\nrow of the heatmap\nrow of the heatmap\nGet the point size\ncurrently set title\nReturns value stored in the heatmap at specified …\nReturns value stored in the heatmap at specified …\nCreate a gnuplot script to plot your heatmap\nCreate a gnuplot script to plot your heatmap\nCreate a gnuplot script to plot your heatmap\nCreate a gnuplot script to plot your heatmap\nCreate a gnuplot script to plot your heatmap\nCreate a gnuplot script to plot your heatmap\nCreate a gnuplot script to plot your heatmap\nCreate a gnuplot script to plot your heatmap\nThe green part\nInternal <code>HeatmapU</code>\nInternal <code>HeatmapF64</code>\nreturns heatmap\nreturns heatmap\nGet index of heatmap corresponding to a coordinate\nNormalizes self\nreturns normalized heatmap\nreturns (column wise) normalized heatmap\nreturns (row wise) normalized heatmap\nreturns height of the heatmap\nreturns height of the heatmap\nReturns reference to current height Histogram\nReturns reference to current height Histogram\nReturns reference to current height Histogram\n#Set hue intensity. Builder pattern Valid values are 0.0 &lt;…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts <code>self</code> into the corresponding enum of <code>GnuplotPallet</code>\nConverts <code>self</code> into the corresponding enum of <code>GnuplotPallet</code>\nreturns normalized heatmap\nreturns (column wise) normalized heatmap\nreturns (column wise) normalized heatmap\nreturns (row wise) normalized heatmap\nChange the legend entry\nBuilder pattern - set low and high value\nGet a mean vector\nGet a mean vector\nIterate over the calculated mean\nIterate over the calculated mean\nInternal slice for mean\nInternal slice for mean\nCreate a heatmap\nCreate a heatmap\nCreate a new Heatmap\nCreate new GnuplotAxis::FromValues\nCreate new, default, GnuplotSettings\nCreate a new color\nInitialize Palette\nCreate a new instance of GnuplotPointSettings\nCreate a new Heatmap\nCreate color from an array\nNormalizes self\nNormalizes self\nBuilder pattern - set color palette\nColor palette for heatmap\nThe red part\nBuilder pattern - remove cb_range\nRemove x_axis\nRemove y_axis\nReset\nReset\nBuilder pattern - set reverse\nCalculate color from gray value. Gray value should be in …\n#Set rotation. Builder pattern Rotation in color space. …\nSet the rotation value. Tics will be displayed rotated to …\nBuilder pattern - set size of terminal\nChoose the size of the point\nSize of the terminal\nBuilder pattern - set start color\nBuilder pattern - set terminal\nwhich terminal to use for gnuplot\nBuilder pattern - set title\ntitle for gnuplot\nconvert color to array,\nTurn into hex representation\ncounts how often the heatmap was hit\ncounts how often the heatmap was hit\nCounts how often the Heatmap was missed, i.e., you tried …\nCounts how often the Heatmap was missed, i.e., you tried …\nUse this to get a “flipped” heatmap\nUse this to get a “flipped” heatmap\nUse this to get a “flipped” heatmap\nUse this to get a “flipped” heatmap\nreturns Vector representing normalized heatmap\nreturns vector representing heatmap, normalized column wise\nreturns vector representing heatmap, normalized row wise\nreturns width of the heatmap\nreturns width of the heatmap\nReturns reference to current width Histogram\nReturns reference to current width Histogram\nReturns reference to current width Histogram\nWrite a heatmap with the given gnuplot Settings\nSame as write_heatmap but it assumes that the heatmap …\nWrite hex representation to a io writer\nwrite string to define this palette in gnuplot to io writer\nWrite heatmap to file\nWrite heatmap to file\nSet x_axis - See GnuplotAxis or try it out\nhow to format the labels of the x axis?\nBuilder pattern - set x_label\nx label for gnuplot\nSet y_axis - See GnuplotAxis or try it out\nhow to format the labels of the y axis?\nBuilder pattern - set y_label\ny label for gnuplot\nthis are the labels\nmaximum value for axis labels\nminimum value for axis labels\nnumber of tics, should be at least 2\nCannot create the histograms due to Alignment issues\nProvides Histogram functionality\nHistogram for binning <code>f32</code> - alias for <code>HistogramFloat&lt;f32&gt;</code>\nHistogram for binning <code>f64</code> - alias for <code>HistogramFloat&lt;f64&gt;</code>\nImplements histogram\nGeneric Histogram struct\ntrait used for mapping values of arbitrary type <code>T</code> to bins…\nDefinition of a Bin\nTrait used to display bins\nWhat type does the displayable BinEntry have?\nImplements Binning\nEfficient binning for <code>i128</code> with arbitrary width\nEfficient binning for <code>i16</code> with arbitrary width\nEfficient binning for <code>i32</code> with arbitrary width\nEfficient binning for <code>i64</code> with arbitrary width\nEfficient binning for <code>i8</code> with arbitrary width\nEfficient binning for <code>isize</code> with arbitrary width\nEfficient binning for <code>u128</code> with arbitrary width\nEfficient binning for <code>u16</code> with arbitrary width\nEfficient binning for <code>u32</code> with arbitrary width\nEfficient binning for <code>u64</code> with arbitrary width\nEfficient binning for <code>u8</code> with arbitrary width\nEfficient binning for <code>usize</code> with arbitrary width\nGeneric binning meant for any integer type\nSomething went wrong wile casting!\nUnable to perform operation on empty slice\nThe bin is defined by two exclusive borders (left, right). …\nThe bin is defined by an exclusive and an inclusive border …\nIt did not work…\nEfficient binning for <code>i128</code> with bins of width 1\nEfficient binning for <code>i16</code> with bins of width 1\nEfficient binning for <code>i32</code> with bins of width 1\nEfficient binning for <code>i64</code> with bins of width 1\nEfficient binning for <code>i8</code> with bins of width 1\nEfficient binning for <code>isize</code> with bins of width 1\nEfficient binning for <code>u128</code> with bins of width 1\nEfficient binning for <code>u16</code> with bins of width 1\nEfficient binning for <code>u32</code> with bins of width 1\nEfficient binning for <code>u64</code> with bins of width 1\nEfficient binning for <code>u8</code> with bins of width 1\nEfficient binning for <code>usize</code> with bins of width 1\nGeneric binning meant for any integer type\nProvides Histogram functionality\nHelper trait for efficient calculations in other …\nPossible Errors of the traits <code>Histogram</code> and <code>HistogramVal</code>\nHistogram for binning <code>f32</code> - alias for <code>HistogramFloat&lt;f32&gt;</code>\nHistogram for binning <code>f64</code> - alias for <code>HistogramFloat&lt;f64&gt;</code>\nHistogram for binning <code>i128</code> - alias for <code>HistogramInt&lt;i128&gt;</code>\nHistogram for binning <code>i128</code> - alias for <code>HistogramFast&lt;i128&gt;</code>\nHistogram for binning <code>i16</code> - alias for <code>HistogramInt&lt;i16&gt;</code>\nHistogram for binning <code>i16</code> - alias for <code>HistogramFast&lt;i16&gt;</code>\nHistogram for binning <code>i32</code> - alias for <code>HistogramInt&lt;i32&gt;</code>\nHistogram for binning <code>i32</code> - alias for <code>HistogramFast&lt;i32&gt;</code>\nHistogram for binning <code>i64</code> - alias for <code>HistogramInt&lt;i64&gt;</code>\nHistogram for binning <code>i64</code> - alias for <code>HistogramFast&lt;i64&gt;</code>\nHistogram for binning <code>i8</code> - alias for <code>HistogramInt&lt;i8&gt;</code>\nHistogram for binning <code>i8</code> - alias for <code>HistogramFastiu8&gt;</code>\nHistogram for binning <code>isize</code> - alias for <code>HistogramInt&lt;isize&gt;</code>\nHistogram for binning <code>isize</code> - alias for …\nHistogram for binning <code>u128</code> - alias for <code>HistogramInt&lt;u128&gt;</code>\nHistogram for binning <code>u128</code> - alias for <code>HistogramFast&lt;u128&gt;</code>\nHistogram for binning <code>u16</code> - alias for <code>HistogramInt&lt;u16&gt;</code>\nHistogram for binning <code>u16</code> - alias for <code>HistogramFast&lt;u16&gt;</code>\nHistogram for binning <code>u32</code> - alias for <code>HistogramInt&lt;u32&gt;</code>\nHistogram for binning <code>u32</code> - alias for <code>HistogramFast&lt;u32&gt;</code>\nHistogram for binning <code>u64</code> - alias for <code>HistogramInt&lt;u64&gt;</code>\nHistogram for binning <code>u64</code> - alias for <code>HistogramFast&lt;u64&gt;</code>\nHistogram for binning <code>u8</code> - alias for <code>HistogramInt&lt;u8&gt;</code>\nHistogram for binning <code>u8</code> - alias for <code>HistogramFast&lt;u8&gt;</code>\nHistogram for binning <code>usize</code> - alias for <code>HistogramInt&lt;usize&gt;</code>\nHistogram for binning <code>usize</code>- alias for <code>HistogramFast&lt;usize&gt;</code>\nImplements histogram\nUsed to get a histogram, which contains the smaller …\nFaster version of HistogramInt for Integers\nGeneric Histogram struct\nGeneric Histogram for integer types\nDistance metric for how far a value is from a valid …\nYour Interval is to large to sample in a reasonable amount …\ntrait used for mapping values of arbitrary type <code>T</code> to bins…\nThe bin is defined by an inclusive and an exclusive border …\nThe bin is defined by two inclusive borders (left, right). …\nTrait for comparing two intervals\nNothing can hit the bin! (left &gt;= right?)\nCannot create the requested overlap!\nCould be NAN, INFINITY or similar\nType returned by <code>self.to_le_bytes()</code>. Depends on how many …\nCannot create requested interval with bins, that all have …\nA histogram without any bins does not make sense!\nYou have done something that can succeed or fail\nInvalid value\nOverflow occurred,\nThe bin consists of a single value. A value is inside the …\nIt worked :)\nUnderflow occurred\nwhich unsigned type corresponds to this type?\nError while casting to usize\nGet bin difference between histograms\ncheck if any bin was not hit yet\ncheck if any bin was not hit yet\ncheck if any bin was not hit yet\ncheck if any bin was not hit yet\nHow many bins the histogram contains\nHow many bins the histogram contains\nHow many bins the histogram contains\nHow many bins the histogram contains\nbinning borders\nconsider using <code>self.bin_iter()</code> instead\nconsider using <code>self.bin_iter()</code> instead\nIterator over the bins\nIterate over all bins\nIterate over all bins\nIterator over all the bins\nIterate over all bins\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterate over bins and hits\nIterates over all bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nIterates over all bins\nGet reference to underlying binning\nGet reference to internal binning\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nThe amount of bins -1\nsimilar to <code>self.borders_clone</code> but does not allocate memory\nsimilar to <code>self.borders_clone</code> but does not allocate memory\nReturns reference to the underlying bin borders\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\nChecked multiply divide\n<code>self.hist[index] += 1</code>, <code>Err()</code> if <code>index</code> out of bounds\n<code>self.hist[index] += 1</code>, <code>Err()</code> if <code>index</code> out of bounds\n<code>self.hist[index] += count</code>, <code>Err()</code> if <code>index</code> out of bounds\nUses SeqCst\ncount val. <code>Ok(index)</code>, if inside of hist, <code>Err(_)</code> if val is …\ncount val. <code>Ok(index)</code>, if inside of hist, <code>Err(_)</code> if val is …\nIterator over all the bins\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\ncalculates some sort of absolute distance to the nearest …\nCreate a histogram, which encapsulates the histograms …\nchecks if the range of two Histograms is equal, i.e., if …\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive). This is the first …\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nget the left most border (inclusive)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nfrom little endian. See implementation for integers in the …\nconvert val to the respective histogram index\nconvert val to the respective histogram index\nconvert val to the respective binning index\nNone if not inside Hist covered zone\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin index\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the respective bin in native unsigned\nGet the number of underlying bins\nthe created histogram\nthe created histogram\nIterator over hit count of bins\nIncrement hit count of bin\nIncrement hit count\nIncrement hit count\nIncrement hit count of bin\n<code>self.hist[index] += 1</code>, <code>Err()</code> if <code>index</code> out of bounds\n<code>self.hist[index] += 1</code>, <code>Err()</code> if <code>index</code> out of bounds\n<code>self.hist[index] += count</code>, <code>Err()</code> if <code>index</code> out of bounds\nIncrement hit count\nIncrement hit count\nIncrement hit count\nIncrement hit count\nDistance metric for how far a value is from a valid …\nReturns the length of the interval\nReturns the length of the interval\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts self into an atomic histogram, such that you may …\nConverts self into a Generic hist, i.e., a histogram …\nCheck if outcome is failure variant\ndoes a value correspond to a valid bin?\ndoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nDoes a value correspond to a valid bin?\nCheck if Outcome is success variant\nget last border from the right\nGet border on the right\nIf the last border is inclusive, this returns the largest …\nTrue if last border is inclusive, false otherwise\nTrue if last border is inclusive, false otherwise\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nGet left border, inclusive\nWill compare leftest bin first. if they are equal: will …\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nIterator over all the bins\nCreate a new Histogram\nCreate a new histogram\nCreate a new interval\nCreate a new Histogram\nCreate a new histogram from an arbitrary binning\nCreate a new histogram from an arbitrary binning\nCreate a new histogram\nCreate new histogram with inclusive borders\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nCreate a new Binning\nopposite of <code>is_inside</code>\nopposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>, so: is the value outside the valid …\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\nOpposite of <code>is_inside</code>\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\npartition the interval\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nReturns the range covered by the bins as a …\nreset the histogram to zero\nreset the histogram to zero\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nGet right border, inclusive\nConvert binning into a AtomicGenericHist\nConvert binning into a AtomicGenericHist\nConvert binning into GenericHist\nConvert binning into GenericHist\nto little endian. See implementation for integers in the …\nTotal number of hits\nAdd other histogram to self\nFor writing a bin\nWriting the header of the bin\nm_beta cannot be infinitiy or minus infinity!\nEnergy function for current state of ensemble returns None\nshort for <code>Metropolis&lt;E, R, S, Res, f32&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, f64&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, i128&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, i16&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, i32&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, i64&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, i8&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, isize&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, u128&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, u16&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, u32&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, u64&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, u8&gt;</code>\nshort for <code>Metropolis&lt;E, R, S, Res, usize&gt;</code>\nCreate a metropolis simulation\nErrors encountered during Metropolis Algorithm\nInvalid nan encountered\nChange, which markov chain is used for the metropolis …\nreturns stored value for the <code>counter</code>, i.e., where to …\nreturns stored value for <code>current_energy</code>\nreturns reference to ensemble\nreturns mutable reference to ensemble\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturns stored <code>m_beta</code> value (-β for metropolis)\nMetropolis Simulation\nMetropolis Simulation\nMetropolis Simulation\nMetropolis simulation\nMetropolis simulation\nMetropolis Simulation\nMetropolis Simulation\nMetropolis simulation\nCreate a new Metropolis struct - used for Metropolis …\nCreate a new Metropolis struct - used for Metropolis …\nresets the <code>counter</code> to 0\nset stored value for <code>current_energy</code>\nsets m_beta (minus beta). Is related to the temperature: …\nchange the <code>stepsize</code>returns Failure if you try to set …\nsets m_beta according to m_beta = -1 / temperature\nreturn current <code>stepsize</code>\nShort for ReplicaExchangeEntropicSampling\nWalker for Replica exchange entropic sampling\nStruct used for entropic sampling with replica exchanges\nrate/fraction of acceptance\nAdd extra information to your Replica Exchange entropic …\nAdd extra information to your Replica Exchange entropic …\nResults of the simulation\nResults of the simulation\nChange step size for markov chain of walkers\nChange step size for markov chain of walkers\nChange sweep size for markov chain of walkers\nChange sweep size for markov chain of walkers\nSanity check\nSanity check\nResults of the simulation\nResults of the simulation\nReturns reference of current energy\nReturns current energy\nIterator over ensembles\nIterator over ensembles\nMutable iterator over ensembles\nMutable iterator over ensembles\nRead access to your extra information\nRead access to your extra information\nWrite access to your extra information\nWrite access to your extra information\nReturns the argument unchanged.\nReturns the argument unchanged.\nread access to your ensembles\nread access to your ensembles\nmut access to your ensembles\nmut access to your ensembles\nread access to internal histogram\nread access to internal histogram\nGet step size for markov chain of walkers\nGet step size for markov chain of walkers\nGet sweep size for markov chain of walkers\nGet sweep size for markov chain of walkers\nReference to internal histogram\nread access to the internal histograms used by the walkers\nread access to the internal histograms used by the walkers\nReturns id of walker\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks threshold\nChecks threshold\nis the simulation finished?\nOld estimate of log10 of probability density\nCurrent estimate of log10 of probability density\nOld non normalized estimate of the natural logarithm of …\nCurrent non normalized estimate of the natural logarithm …\nMerge probability density of multiple rees simulations\nMerge probability density of multiple rees simulations\nMerge probability density of multiple rees simulations\nResult of the simulations!\nResult of the simulations!\nGet the number of intervals present\nGet the number of intervals present\nHow many walkers are there in total?\nHow many walkers are there in total?\nHow many replica exchanges were proposed until now?\nIterator over roundtrips done by REES\nIterator over roundtrips done by REES\nRefine the estimate of the probability density functions\nRefine the estimate of the probability density functions\nRefine current probability density estimate\nHow many markov steps were rejected until now\nfraction of how many replica exchanges were accepted and …\nHow many successful replica exchanges were performed until …\nIterate over the roundtrips done by the REWL\nIterate over the roundtrips done by the REWL\nPerform the Replica exchange simulation\nPerform the Replica exchange simulation\nPerform the Replica exchange simulation\nPerform the Replica exchange simulation\nHow many entropic steps were performed until now?\nstep size for markov steps\nChange step sitze for markov steps\nReturn step threshold\nSwap the extra vector\nSwap the extra vector\nSweep\nSweep\nhow many steps per sweep\nchange how many steps per sweep are performed\nRemove extra vector\nRemove extra vector\nReturns internal walkers\nReturns internal walkers\nReturns number of walkers per interval\nReturns number of walkers per interval\nHistogram vector needs to contain at least one entry.\nYou tried to pass an empty slice\nContains the error value\nEnum used internally\nResult of glueing. See Glued\nEach histogram needs to have <strong>at least</strong> two bins. Though …\nhistograms must have at least two bins - everything else …\nThere is no interval that is “more left” then this one\nThe length of the histogram vector has to be equal to the …\nLength of histogram vector and ensemble vector has to be …\nNo negative threshold value allowed\nlog_f_threshold must not be negative\nThe threshold cannot be subnormal\nThe threshold for <code>log_f</code> needs to be a normal number.That …\nNone of the above\nContains the success value\nEfficient replica exchange Wang landau\nUse this to create a replica exchange wang landau …\nShort for <code>ReplicaExchangeWangLandau</code>, which you can look at …\nShort for <code>ReplicaExchangeWangLandauBuilder</code>\nErrors\nErrors encountered during the creation of a Rewl struct (<strong>R</strong>…\nWalker for Replica exchange Wang Landau\nThere is no interval that is “more right” then this one\nError types for threshold log_f\nThe threshold is not allowed to be zero\nrate/fraction of acceptance\nResults of the simulation\nResults of the simulation\nChange step size for markov chain of walkers\nChange step size for markov chain of walkers\nChange sweep size for markov chain of walkers\nChange sweep size for markov chain of walkers\nSanity check\nSanity check\nResults of the simulation\nResults of the simulation\nReturns reference of current energy\nReturns current energy\nReturns current energy\nIterator over ensembles\nIterator over ensembles\nMutable iterator over ensembles\nMutable iterator over ensembles\nRead access to the ensembles\nRead access to the ensembles\nFraction of finished intervals\nFraction of finished intervals\nIs the interval in a valid starting configuration?\nIs the interval in a valid starting configuration?\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a builder to create a replica exchange wang landau …\nCreate a builder to create a replica exchange wang landau …\nCreate a builder to create a replica exchange wang landau …\nCreate a builder to create a replica exchange wang landau …\nnew rewl builder\nnew rewl builder\nread access to your ensembles\nread access to your ensembles\nmut access to your ensembles\nmut access to your ensembles\nread access to internal histogram\nread access to internal histogram\nGet Ids\nGet Ids\nGet step size for markov chain of walkers\nGet step size for markov chain of walkers\nGet sweep size for markov chain of walkers\nGet sweep size for markov chain of walkers\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nReference to internal histogram\nread access to the internal histograms used by the walkers\nRead access to histograms\nread access to the internal histograms used by the walkers\nRead access to histograms\nReturns id of walker\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into Rees\nConvert into Rees\nConvert into Rees\nConvert into Rees\nIs the simulation finished?\nIs the simulation finished?\nreturns largest value of factor log_f present in the …\nreturns largest value of factor log_f present in the …\nCurrent estimate of log10 of probability density\nCurrent non normalized estimate of the natural logarithm …\nCurrent (logarithm of) factor f\nLog_f factors of the walkers\nLog_f factors of the walkers\nMaximum of roundtrips\nMaximum of roundtrips\nMerge probability density of multiple rewl simulations\nMerge probability density of multiple rewl simulations\nMinimum of roundtrips\nMinimum of roundtrips\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nGet the number of intervals present\nGet the number of intervals present\nHow many replica exchanges were proposed until now?\nHow many markov steps were rejected until now\nfraction of how many replica exchanges were accepted and …\nHow many successful replica exchanges were performed until …\nRoundtrips\nRoundtrips\nchange the threshold of log_f\nchange the threshold of log_f\nPerform the Replica exchange wang landau simulation\nPerform the Replica exchange wang landau simulation\nPerform the Replica exchange wang landau simulation\nPerform the Replica exchange wang landau simulation\nHow many steps were performed until now?\nstep size for markov steps\nChange step sitze for markov steps\nAccess step sizes of individual intervals\nAccess step sizes of individual intervals\nChange step size of individual intervals\nChange step size of individual intervals\nSweep\nSweep\nhow many steps per sweep\nchange how many steps per sweep are performed\nAccess sweep size of individual intervals\nAccess sweep size of individual intervals\nChange sweep size of individual intervals\nChange sweep size of individual intervals\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nCreate <code>Rewl</code>, i.e., Replica exchange wang landau simulation\nRead access to internal rewl walkers\nRead access to internal rewl walkers\nReturns number of walkers per interval\nReturns number of walkers per interval\nWhich mode is this walker currently in?\nAccess internal random number generator\nCreate a markov chain by doing markov steps\nFor easy sampling of your ensemble\nMarkov step\nAccumulating markov step\nMarkov steps\nAccumulating markov steps\nAccumulating markov steps\nMarkov steps without return\nRandomizes self according to  model\nAccess RNG\ndo the following <code>times</code> times:\ndo the following <code>times</code> times:\nFunction called whenever the steps are accepted.\nFunction called whenever the steps are rejected.\nIf you need to exchange the internal rng\nundo a markov step, return result-stateif you want to undo …\nundo a markov, <strong>panic</strong> on invalid result statefor undoing …\nUndo markov steps\nUndo markov steps\ncheck refine has to be at least 1\nDimensions do not match!\nStill Gathering Statistics, this is only an estimate!\nStep limit exceeded without finding valid starting point\nbestof has to be at least 1 and at most the number of …\nlog_f has to fullfill 0.0 &lt; log_f &lt; 10.0\n<code>log_f_threshold</code>can never be negative or zero! it also …\n<code>trial_step_min &lt;= trial_step_max</code> has to be true\nAll values inside the initial guess have to be finite\nStill in the process of gathering statistics Not enough to …\nyou have to call one of the\nUse 1/T approachrefine each step by: …\nUsing original wang landau, i.e., refine every time when …\nPossible errors when setting initial guess\nTraits for quantities that all Wang Landau simulations have\nThe 1/t Wang Landau approach comes from this paper\nAdaptive WangLandau 1/t\nHelper trait, so that you have to type less\ntrait to request the current energy from a WangLandau …\ntrait to request a reference to the current (state of the) …\nList of possible errors\ntrait to request the current histogram from a WangLandau …\nLook at the paper\nreturns the last accepted <code>Energy</code> calculated <code>None</code> if no …\nreturn reference to current state of ensemble\nmutable reference to current state\nEstimate accept/reject statistics\nIs the simulation has finished the process of rebuilding …\nFraction of steps accepted since the statistics were reset …\nCalculate, which fraction of steps were accepted\nCalculate, which fraction of steps were accepted\nTracks progress\nCalculate, which fraction of steps were rejected\nCalculate, which fraction of steps were rejected\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturns current histogram\nFind a valid starting Point\nFind a valid starting Point\nFind a valid starting Point\nFind a valid starting Point\nFind a valid starting Point\nFind a valid starting Point\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns internal ensemble, histogram and Rng\nChecks wang landau threshold\nChecks wang landau threshold\nCheck if <code>self</code> is initialized\nCheck if <code>self</code> is initialized\ntrue if self is <code>Refine1T</code> variantfalse otherwise\ntrue if self is <code>RefineOriginal</code> variantfalse otherwise\nIs the simulation in the process of rebuilding the …\nCurrent (non normalized) estimate of ln(P(E))\nCurrent (non normalized) estimate of log_base(P(E))\nCurrent (non normalized) estimate of log_base(P(E))\nCurrent (non normalized) estimate of log10(P(E))\nCurrent (non normalized) estimate of log10(P(E))\nget current value of log_f\nreturns currently set threshold for log_f\nLargest possible markov step (<code>m_steps</code> of MarkovChain …\nSmallest possible markov step (<code>m_steps</code> of MarkovChain …\nReturns current wang landau mode\nNew WangLandauAdaptive\nCreate a new WangLandau simulation\n<code>samples_per_trial</code> - how often a specific step_size should …\nSet the initial guess for the non-normalized probability …\nTry to set the threshold.\nCounter\nCounter\nCounter\nHow many steps were accepted until now?\nHow many steps were rejected until now?\nWang Landau\nWang Landau\nWang Landau simulation\nWang Landau - efficient energy calculation\nWang Landau\nWang Landau\nWang Landau Step\nWang Landau Step\nAccumulating wang landau step\nWang Landau Step\nWang Landau Step\nWang Landau Step\nWang Landau\nWang Landau\nWang Landau Simulation\nWang Landau\nWang Landau\nWang Landau\nWrites Information about the simulation to a file. E.g. …")